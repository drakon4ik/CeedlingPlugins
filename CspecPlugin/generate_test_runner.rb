
# Based on Unity Project - Mike Karlesky, Mark VanderVoord, Greg Williams

def run(input_file, output_file, options=nil)
    tests = []
    testfile_includes = []
    used_mocks = []
    
    @options.merge!(options) unless options.nil?
    module_name = File.basename(input_file)
    
    #pull required data from source file
    File.open(input_file, 'r') do |input|
      tests               = find_tests(input)
   #   testfile_includes   = find_includes(input)
    end

#    #build runner file
#    generate(input_file, output_file, tests, used_mocks)
    
#    #determine which files were used to return them
#    all_files_used = [input_file, output_file]
#    all_files_used += testfile_includes.map {|filename| filename + '.c'} unless testfile_includes.empty?
#    all_files_used += @options[:includes] unless @options[:includes].empty?
#    return all_files_used.uniq
  end
 
 def generate(input_file, output_file, tests)
    File.open(output_file, 'w') do |output|
      create_header(output)
 #     create_externs(output, tests, used_mocks)
 #     create_mock_management(output, used_mocks)
 #     create_suite_setup_and_teardown(output)
 #     create_reset(output, used_mocks)
 #     create_main(output, input_file, tests)
		create_main(output, input_file, tests)
    end
  end


 def find_tests(input_file)
    tests_raw = []
    tests_args = []
    tests_and_line_numbers = []
    
    input_file.rewind
    source_raw = input_file.read
    source_scrubbed = source_raw.gsub(/\/\/.*$/, '')           # remove line comments
    source_scrubbed = source_scrubbed.gsub(/\/\*.*?\*\//m, '') # remove block comments
	
	#p  source_scrubbed     
	lines = source_scrubbed.split(/(^\s*\#.*$)                 # Treat preprocessor directives as a logical line
                              | (;|\{|\}) /x)                  # Match ;, {, and } as end of lines

    lines.each_with_index do |line, index|
      #find tests
      if line =~ /^\s*DESCRIBE\s*\((.*),(.*)\)/
         name = $2
        description = $1

 
	
        tests_and_line_numbers << { :description => description, :name  => name }

      end
      
    end

    return tests_and_line_numbers
  end

def create_header(output)
    output.puts('/* AUTOGENERATED FILE. DO NOT EDIT. */')
    output.puts("\n//=======Automagically Detected Files To Include=====")
    output.puts("#include <stdio.h>")
    output.puts('#include <setjmp.h>')
    output.puts("#include \"cspec_output_header.h\"")
    output.puts("#include \"cspec_output_verbose.h\"")
    output.puts("#include \"cspec_output_unit.h\"")
    output.puts('#include "CException.h"')
end

  def create_runtest(output, used_mocks)
    cexception = @options[:plugins].include? :cexception
    va_args1   = @options[:use_param_tests] ? ', ...' : ''
    va_args2   = @options[:use_param_tests] ? '__VA_ARGS__' : ''
    output.puts("\n//=======Test Runner Used To Run Each Test Below=====")
    output.puts("#define RUN_TEST_NO_ARGS") if @options[:use_param_tests] 
    output.puts("#define RUN_TEST(TestFunc, TestLineNum#{va_args1}) \\")
    output.puts("{ \\")
    output.puts("  Unity.CurrentTestName = #TestFunc#{va_args2.empty? ? '' : " \"(\" ##{va_args2} \")\""}; \\")
    output.puts("  Unity.CurrentTestLineNumber = TestLineNum; \\")
    output.puts("  Unity.NumberOfTests++; \\")
    output.puts("  if (TEST_PROTECT()) \\")
    output.puts("  { \\")
    output.puts("    CEXCEPTION_T e; \\") if cexception
    output.puts("    Try { \\") if cexception
    output.puts("      CMock_Init(); \\") unless (used_mocks.empty?) 
    output.puts("      setUp(); \\")
    output.puts("      TestFunc(#{va_args2}); \\")
    output.puts("      CMock_Verify(); \\") unless (used_mocks.empty?)
    output.puts("    } Catch(e) { TEST_ASSERT_EQUAL_HEX32_MESSAGE(CEXCEPTION_NONE, e, \"Unhandled Exception!\"); } \\") if cexception
    output.puts("  } \\")
    output.puts("  CMock_Destroy(); \\") unless (used_mocks.empty?)
    output.puts("  if (TEST_PROTECT() && !TEST_IS_IGNORED) \\")
    output.puts("  { \\")
    output.puts("    tearDown(); \\")
    output.puts("  } \\")
    output.puts("  UnityConcludeTest(); \\")
    output.puts("}\n")
  end
  
  def create_main(output, filename, tests)
    output.puts("\n\n//=======MAIN=====")
    output.puts("int main(void)")
    output.puts("{")
    output.puts("  CSpecOutputStruct* output = CSpec_NewOutputVerbose();")
   
      tests.each do |test|
      p test
   
          output.puts("  CSpec_Run( DESCRIPTION( #{test[:description]} ), output);")

      end
 
    output.puts()
    
    output.puts("}")
  end



#p run("tests/test_spec.c", "output.c")

generate("tests/test_spec.c","out.c", run("tests/test_spec.c", "output.c"))
